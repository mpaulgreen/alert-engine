# Models Documentation

This directory contains the core data models used by the Alert Engine system. These models define the structure of JSON payloads that are sent to and received from Kafka topics, as well as the configuration structures for alert rules.

## Overview

The Alert Engine system uses three main types of models:

1. **LogEntry** - Represents incoming log data from OpenShift applications (consumed from Kafka)
2. **Alert** - Represents triggered alert instances (generated by the system, sent to notification systems)
3. **AlertRule** - Represents alert configuration rules (stored in Redis, used to evaluate log entries)

## LogEntry Model

The `LogEntry` model represents structured log data that comes **INTO** the system from Kafka topics. This is the primary input data structure that the Alert Engine processes.

### Structure

```go
type LogEntry struct {
    Timestamp  time.Time      `json:"timestamp"`
    Level      string         `json:"level"`
    Message    string         `json:"message"`
    Kubernetes KubernetesInfo `json:"kubernetes"`
    Host       string         `json:"host"`
    Raw        string         `json:"raw,omitempty"`
}

type KubernetesInfo struct {
    Namespace string            `json:"namespace"`
    Pod       string            `json:"pod"`
    Container string            `json:"container"`
    Labels    map[string]string `json:"labels"`
}
```

### JSON Example

```json
{
  "timestamp": "2024-01-15T10:30:45.123Z",
  "level": "ERROR",
  "message": "Database connection failed: timeout after 30s",
  "kubernetes": {
    "namespace": "production",
    "pod": "user-service-7b6f9c8d4-xyz12",
    "container": "user-service",
    "labels": {
      "app": "user-service",
      "version": "1.2.3",
      "environment": "production"
    }
  },
  "host": "worker-node-01",
  "raw": "{\"timestamp\":\"2024-01-15T10:30:45.123Z\",\"level\":\"ERROR\",...}"
}
```

### Field Descriptions

- **timestamp**: When the log entry was created
- **level**: Log level (DEBUG, INFO, WARN, ERROR, FATAL)
- **message**: The actual log message content
- **kubernetes**: Kubernetes-specific metadata added by Vector
  - **namespace**: Kubernetes namespace where the pod is running
  - **pod**: Name of the pod that generated the log
  - **container**: Name of the container within the pod
  - **labels**: Key-value pairs of Kubernetes labels
- **host**: The host/node where the log was generated
- **raw**: Original raw message (used for debugging)

## Alert Model

The `Alert` model represents triggered alert instances that are generated when log entries match configured alert rules. These can be sent to notification systems or other Kafka topics.

### Structure

```go
type Alert struct {
    ID          string    `json:"id"`
    RuleID      string    `json:"rule_id"`
    RuleName    string    `json:"rule_name"`
    LogEntry    LogEntry  `json:"log_entry"`
    Timestamp   time.Time `json:"timestamp"`
    Severity    string    `json:"severity"`
    Status      string    `json:"status"`
    Message     string    `json:"message"`
    Count       int       `json:"count"`
}
```

### JSON Example

```json
{
  "id": "alert-12345",
  "rule_id": "db-connection-error-rule",
  "rule_name": "Database Connection Error Alert",
  "log_entry": {
    "timestamp": "2024-01-15T10:30:45.123Z",
    "level": "ERROR",
    "message": "Database connection failed: timeout after 30s",
    "kubernetes": {
      "namespace": "production",
      "pod": "user-service-7b6f9c8d4-xyz12",
      "container": "user-service",
      "labels": {
        "app": "user-service",
        "version": "1.2.3"
      }
    },
    "host": "worker-node-01"
  },
  "timestamp": "2024-01-15T10:30:45.456Z",
  "severity": "high",
  "status": "pending",
  "message": "Database connection error detected in production namespace",
  "count": 1
}
```

### Field Descriptions

- **id**: Unique identifier for the alert instance
- **rule_id**: ID of the alert rule that triggered this alert
- **rule_name**: Human-readable name of the alert rule
- **log_entry**: The log entry that triggered the alert
- **timestamp**: When the alert was generated
- **severity**: Alert severity level (low, medium, high, critical)
- **status**: Current status of the alert (pending, sent, failed)
- **message**: Human-readable alert message
- **count**: Number of times this alert has been triggered

## AlertRule Model

The `AlertRule` model defines the configuration for when alerts should be triggered. These rules are evaluated against incoming log entries.

### Structure

```go
type AlertRule struct {
    ID          string            `json:"id"`
    Name        string            `json:"name"`
    Description string            `json:"description"`
    Enabled     bool              `json:"enabled"`
    Conditions  AlertConditions   `json:"conditions"`
    Actions     AlertActions      `json:"actions"`
    CreatedAt   time.Time         `json:"created_at"`
    UpdatedAt   time.Time         `json:"updated_at"`
}

type AlertConditions struct {
    LogLevel    string            `json:"log_level"`
    Namespace   string            `json:"namespace"`
    Service     string            `json:"service"`
    Keywords    []string          `json:"keywords"`
    Threshold   int               `json:"threshold"`
    TimeWindow  time.Duration     `json:"time_window"`
    Operator    string            `json:"operator"`
}

type AlertActions struct {
    SlackWebhook string           `json:"slack_webhook"`
    Channel      string           `json:"channel"`
    Severity     string           `json:"severity"`
}
```

### JSON Example

```json
{
  "id": "db-connection-rule",
  "name": "Database Connection Error Rule",
  "description": "Alert when database connection errors occur",
  "enabled": true,
  "conditions": {
    "log_level": "ERROR",
    "namespace": "production",
    "service": "user-service",
    "keywords": ["database", "connection", "failed"],
    "threshold": 3,
    "time_window": "5m",
    "operator": "gt"
  },
  "actions": {
    "slack_webhook": "https://hooks.slack.com/services/...",
    "channel": "#alerts",
    "severity": "high"
  },
  "created_at": "2024-01-15T09:00:00Z",
  "updated_at": "2024-01-15T09:00:00Z"
}
```

### Field Descriptions

- **id**: Unique identifier for the alert rule
- **name**: Human-readable name of the rule
- **description**: Detailed description of what the rule does
- **enabled**: Whether the rule is active
- **conditions**: Criteria that must be met to trigger the alert
  - **log_level**: Log level to match (DEBUG, INFO, WARN, ERROR, FATAL)
  - **namespace**: Kubernetes namespace to monitor
  - **service**: Service name to monitor
  - **keywords**: Keywords that must be present in the log message
  - **threshold**: Number of matching logs required
  - **time_window**: Time window for threshold evaluation
  - **operator**: Comparison operator (gt, lt, eq, contains)
- **actions**: Actions to take when the alert is triggered
  - **slack_webhook**: Slack webhook URL for notifications
  - **channel**: Slack channel to send alerts to
  - **severity**: Severity level for the alert

## Data Flow

The Alert Engine system processes data in the following flow:

1. **Consumption**: LogEntry JSON payloads are consumed from Kafka topics
   ```go
   var logEntry models.LogEntry
   json.Unmarshal(msg.Value, &logEntry)
   ```

2. **Processing**: Log entries are evaluated against configured AlertRule instances
   ```go
   alertEngine.EvaluateLog(logEntry)
   ```

3. **Alert Generation**: When conditions are met, Alert instances are created
   ```go
   alert := models.Alert{
       ID:       generateAlertID(),
       RuleID:   rule.ID,
       LogEntry: logEntry,
       // ... other fields
   }
   ```

4. **Notification**: Alerts are sent to configured notification systems (Slack, etc.)

## Usage Examples

### Creating a LogEntry

```go
logEntry := models.LogEntry{
    Timestamp: time.Now(),
    Level:     "ERROR",
    Message:   "Service unavailable",
    Kubernetes: models.KubernetesInfo{
        Namespace: "production",
        Pod:       "api-server-123",
        Container: "api-server",
        Labels: map[string]string{
            "app": "api-server",
            "version": "1.0.0",
        },
    },
    Host: "worker-node-01",
}
```

### Creating an AlertRule

```go
rule := models.AlertRule{
    ID:          "service-error-rule",
    Name:        "Service Error Alert",
    Description: "Alert when service errors occur",
    Enabled:     true,
    Conditions: models.AlertConditions{
        LogLevel:   "ERROR",
        Namespace:  "production",
        Keywords:   []string{"service", "unavailable"},
        Threshold:  1,
        TimeWindow: 5 * time.Minute,
        Operator:   "gt",
    },
    Actions: models.AlertActions{
        SlackWebhook: "https://hooks.slack.com/services/...",
        Channel:      "#alerts",
        Severity:     "high",
    },
    CreatedAt: time.Now(),
    UpdatedAt: time.Now(),
}
```

### JSON Marshaling/Unmarshaling

```go
// Convert struct to JSON
jsonData, err := json.Marshal(logEntry)
if err != nil {
    log.Printf("Error marshaling log entry: %v", err)
}

// Convert JSON to struct
var logEntry models.LogEntry
err := json.Unmarshal(jsonData, &logEntry)
if err != nil {
    log.Printf("Error unmarshaling log entry: %v", err)
}
```

## Supporting Models

### LogFilter

Used for filtering log queries:

```go
type LogFilter struct {
    Namespace  string    `json:"namespace,omitempty"`
    Service    string    `json:"service,omitempty"`
    LogLevel   string    `json:"log_level,omitempty"`
    StartTime  time.Time `json:"start_time,omitempty"`
    EndTime    time.Time `json:"end_time,omitempty"`
    Keywords   []string  `json:"keywords,omitempty"`
    Limit      int       `json:"limit,omitempty"`
}
```

### LogStats

Used for tracking log processing statistics:

```go
type LogStats struct {
    TotalLogs     int64              `json:"total_logs"`
    LogsByLevel   map[string]int64   `json:"logs_by_level"`
    LogsByService map[string]int64   `json:"logs_by_service"`
    LastUpdated   time.Time          `json:"last_updated"`
}
```

### AlertStatus

Used for tracking alert status:

```go
type AlertStatus struct {
    RuleID      string    `json:"rule_id"`
    LastTrigger time.Time `json:"last_trigger"`
    Count       int       `json:"count"`
    Status      string    `json:"status"`
}
```

## Notes

- All models use JSON tags for proper serialization/deserialization
- Time fields use RFC3339 format when serialized to JSON
- The `Raw` field in LogEntry contains the original message for debugging purposes
- Redis tags are used for models that are stored in Redis cache
- All models are designed to be thread-safe and can be used in concurrent environments 